#### Metatables 和 Metamethods

在Lua中，可以通过Metatable来改变table的行为，例如使用metatables可以定义Lua如何计算两个table的相加操作a+b，Lua中每个表都有其metatable，Lua创建的表默认不带metatable

```lua
t={}
print(getmetatable(t))   --输出nil

--使用setmetatable函数设置或者改变一个表的metatable
t1={}
setmetatable(t,t1) --t1成为t的metatable
```

* 算术关系的metamethods

  | 模式     | 描述               |
  | -------- | ------------------ |
  | __add    | 对应的运算符 '+'.  |
  | __sub    | 对应的运算符 '-'.  |
  | __mul    | 对应的运算符 '*'.  |
  | __div    | 对应的运算符 '/'.  |
  | __mod    | 对应的运算符 '%'.  |
  | __unm    | 对应的运算符 '-'.  |
  | __concat | 对应的运算符 '..'. |
  | __eq     | 对应的运算符 '=='. |
  | __lt     | 对应的运算符 '<'.  |
  | __le     | 对应的运算符 '<='. |

  用于设置Lua中表对应于不同运算符的逻辑(有点类似于c++里面的符号重载的感觉)

  例如

  ```Lua
  t={x=1,y=2}
  mt={}
  mt.__add=function(a,b)      
  	a.x=a.x+b.x
  	a.y=a.y+b.y
  	return a
  end
  setmetatable(t,mt)
  
  t1={x=2,y=3}
  t=t+t1       -- t和t1将作为mt._add函数的a和b参数传入
  
  print(t["x"]) --输出3
  print(t["y"]) --输出5
  ```

* 关系运算的metamethods

  可以使用metamethods：\_\_eq(等于)、\_\_lt(小于) 、\_\_le(小于等于)给关系运算符赋予特殊含义

   例如

  ```lua
  t={x=1,y=2}
  mt={}
  mt.__eq=function(a,b)
  	return a.x==b.x
  end
  setmetatable(t,mt)
  
  t1={x=2,y=3}
  print(t==t1)   --false
  t["x"]=2 
  print(t==t1)   --true
  ```

* 库定义的metamethods

  * \_\_tosring

    print函数会调用tosring函数来格式化它的输出，在格式化某个对象的时候，tostring函数会先检查对象是否存在一个带有\_\_tostring方法的metatable，如果存在则调用该方法来完成格式化

    ```lua
    t={x=1,y=2}
    mt={}
    mt.__tostring=function ()
    	return "hello world"
    end
    
    setmetatable(t,mt)
    
    print(t)     --输出"hello world"
    
    ```

  * \_\_metatable

    如果对metatable这是了__metatable的值,getmetatable将返回这个值，而调用setmetatable将会报错

    ```lua
    Set.mt.__metatable = "not your business"
    
    s1 = Set.new{}
    
    print(getmetatable(s1))     --> not your business
    
    setmetatable(s1, {})
    
    stdin:1: cannot change protected metatable
    ```

* 表相关的metamethods

    * __index

      在访问一个表不存在的域的时候，Lua解释器回去查找__index metamethod,如果不存在，则返回nil，如果存在则返回\_\_index metamethod返回结果

      ```lua
      t={}
      mt={1,2,3}
      --也可以直接用一张表来给mt.__index赋值，如mt.__index=mt
      mt.__index=function(t,k)    
      	return mt[k]
      end
      setmetatable(t,mt)
      print(t[1])                   --输出1,运行时,t和1作为__index函数的t和k参数传入
      ```

    * __newindex

      用于对表的更新，当对表中不存在的值赋值的时候，解释器就会查找__newindex metamethod，如果存在则调用这个函数而不进行赋值操作

      ```lua
      t={}
      mt={}
      mt.__newindex=function(t,k,v)
      	rawset(t,k,v)     --此时调用t[k]=v会产生无限递归导致栈溢出
      end
      setmetatable(t,mt)
      t["x"]=20    --t,"x",20将作为t,k,v传入__newindex方法
      print(t["x"]) 
      ```

    * 有默认值的表

      ```lua
      --使用__index可以给与表中不存在的元素赋予默认值
      function setDefault(t,d)
      	local mt={}
      	mt.__index=function(t,v)
      		return d
      	end
          setmetatable(t,mt)
      end
      --使用上述方法会覆盖t之前的metatable
      --改进版，可以保留原来的metatable
      function setDefault(t,d)
      	mt=getmetatable(t)
      	mt=mt or {}
      	setmetatable(t,mt)
      	mt.__index=function(t,v)
      		return d
      	end
      end
      ```

    * 只读表

      ```lua
      function readOnly(t)
      	local ret={}
      	local mt={}
      	function mt.__index(table,k)
      		return t[k]
      	end
      	function mt.__newindex(table,k,v)
      		print("error")
      	end
      	setmetatable(ret,mt)
      	return ret
      end
      
      a=readOnly{1,2,3,4}
      --输出1、2、3、4
      for i=1,4 do
      	print(a[i])
      end
      a[5]="2222"   --输出error 无法对表a进行赋值
      ```

      

      

  