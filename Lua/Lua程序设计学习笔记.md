### Lua程序设计

本文档为《Lua程序设计》的学习笔记

---

书中对Lua的特性描述：

* 可扩展性
* 简易性
* 高效
* 可移植性



《Lua程序设计》结构：

* 介绍了语言本身，展示了语言所具有的所有能力。
* 深入介绍table 数据结构 持久化 包和面向对象编程
* Lua标准库
* Lua与C之间的API

---

#### 目录

[TOC]

---

遗留问题：

双精度浮点数

动态链接 8.2

string库 math库

15章

####第一部分

第一部分主要介绍了Lua的基础语法知识

第一章 通过示例展示了Lua的使用

第二章 介绍了Lua的8种类型

第三章 表达式（操作符、构造式）

第四章 语句（赋值、块、控制结构）

第五章 函数 （返回值、参数）

第六章 函数（闭包、局部函数、尾调用）

第七章 迭代器

第八章 编译及错误处理

第九章 协同程序

第十章 两个示例

6~9章需要重点掌握

#####第一章 开始

* 安装Lua

  * [下载Lua For Windows](https://code.google.com/archive/p/luaforwindows/downloads)
  * 下了安装不了 404
  * [GitHub下载](https://github.com/rjpcomputing/luaforwindows)

* **1.1程序块chunk**

  一个程序块也就是一连串的语句或命令

  在命令行交互模式中，解释器会将所输入的每行内容作为一个完整的程序块来解释

  ```lua
  local a = 1 -- 局部变量
  print(a) -- => nil 另一个程序块 无法获得a的值
  
  a = 1 -- 全局变量
  pring(a) -- => 1
  
  dofile("test.lua") -- 执行文件
  ```

  **注：交互模式一般不会用到 稍微了解即可**

* **1.2词法规范**

  * 不能以数字开头
  * _XXXX 特殊用途(避免使用)  _ 哑巴变量(**是什么类型的值呢？**)
  * Lua有大小写之分
  * 保留字 注意 repeat和until

* **1.3全局变量**
  * 删除全局变量 将其赋值为nil
  * Lua中直接赋值的变量均为全局变量

* **1.4解释器程序**

#####第二章 类型与值

8种基础类型 `nil` ` bool` ` number` ` string` `userdata` `function` `thread` `table`

type()用来返回某个值的类型 返回的是一个字符串

函数作为**第一类值**来看待 可以像操作其他值一样来操作函数

* **2.1nil**

* **2.2boolean**

  * false 和 nil 为**假** 其余为**真** 0和空字符串也为真

* **2.3number**

  * Lua没有整数类型 采用**双精度浮点数**

  * 可以通过重新编译来支持其他类型表示数字

  * **双精度浮点数**

    [双精度与单精度的区别](https://www.zhihu.com/question/26022206)

    double(双) float(单)

    ```
    精度主要取决于尾数部分的位数，float为23位，除去全部为0的情况以外，最小为2的-23次方，约等于1.19乘以10的-7次方，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。  类似，double 尾数部分52位，最小为2的-52次方，约为2.22乘以10的-16次方，所以精确到小数点后15位，有效位数为16位。
    ```

    双精度：64位（符号位1 + 指数11 + 小数52）

    **数值 = 尾数 × 底数 ^ 指数，（附加正负号）** 

* **2.4string**

  * Lua采用8位编码
  * 字符串是不可改变的值 只有通过新建一个字符串来修改
  * Lua能够高效地处理长字符串
  * \用来转义
  * 匹配的双方括号来界定一个字母字符串`[[ ... ]]`  Lua不会解释其中的转义序列 在[[之间加=来避免和字符串中的内容冲突(即字符串中包含]])
  * Lua提供了运行时 数字与字符串 的自动转换
  * 字符串前加`#`来获取长度
  * 使用 .. 作为字符串连接符 与数字之间要有空格

* **2.5table**

  * table永远是匿名的，一个持有table的变量和table之间没有固定的关联性（程序持有一个引用/指针）
  * 全局变量存储在table中 _G
  * a.x <=> a["x"]  以.来索引是lua提供的对于a["x"]形式的语法糖
  * Lua以1作为索引的起始值
  * `#`操作符计算长度时从1开始 遇到nil时结束
  * `table.maxn`返回一个数组的最大正索引数

* **2.6function**

  * 第一类值
  * 在后面详细讨论

* **2.7userdata(自定义类型)**

  * 用于表示一种由应用程序或C语言库所创建的新类型

  * 只能进行赋值和相等性测试

* **2.8thread**

  * 第九章

##### 第三章 表达式

`有别于传统的是，表达式中还可以包括函数定义和table构造式`

Lua表达式中可以包含函数定义和table构造式

* **3.1算数操作符**

  * `^` 指数操作符 `%`取模操作符
  * `a%b` == `a - floor(a/b)*b`  `-180 %360 = 180`
  * 整数取模 结果符号与第二个参数相同
  * `x%1`就是x的小数部分

* **3.2关系操作符**

  * 对于table userdata function lua是做引用比较的

  * 只能对两个数字或两个字符创作大小性比较

    比较数字按照传统的数字大小进行，比较字符串按照字符顺序进行

* **3.3逻辑操作符**

  * `and`和 `or`都使用**短路求值**

* **3.4字符串连接**

  使用`..`来连接字符串

  Lua中字符串时不可变的值 使用连接操作符只会创建一个新的字符串 而不会对其原操作数进行任何修改

* **3.5优先级**

  只有`^` 和 `..`是右结合的

   **同一优先级的运算符，运算次序由结合方向所决定。** 

* **3.6table构造式**

  * a = {x= 10}  <=> a["x"] = 10

  * ```lua
    -- 列表风格初始化
    a = {1, 2, 3}
    -- 记录风格初始化
    a = {x = 1, y = 2,}
    
    -- 混合风格
    a = {x = 1, y = 2; 1, 2, 3}
    -- 在一个构造式中可以用分号代替逗号 通常用于将不同风格分开
    --
    a = { + = 2} -- 错误
    a = {["+"] = 2} -- 正确
    ```

  * 链表实现：

    ```lua
    list = nil
    for i, v in ipairs(data) do
    
    	list = {next = list, value = v}
    
    end
    ```


#####第四章 语句

Lua还支持一些不太常见的语句，例如 **多重赋值**和**局部变量声明**

* **4.1赋值**

  * 多重赋值时 先对右边的所有元素求值，然后才执行赋值

    可以实现a, b = b, a

    若要初始化一组变量，应为每个变量提供一个值

* **4.2局部变量与块**

  * 局部变量的作用域仅限于声明它们的那个块

  * 一个块是一个控制结构的执行体、一个函数的执行体或者一个程序块

  * do end 显示界定**块**

  * ```lua
    local a = a
    ```

    创建一个局部变量a 并用全局变量a的值来初始化它。**可以加速在当前作用域中对a的访问**

* **4.3控制结构**

  * if while repeat for

  * repeat-until语句重复执行循环体直到条件为真时结束 **至少执行一次**

    ```lua
    repeat
    	line = io.read()
    until line ~= ""
    ```

    **在Lua中 声明在循环体中的局部变量的作用域包括了条件测试**

  * for语句有两种形式：数字型for 和 泛型for

  * 数字型for 

    	三个表达式是在循环开始前一次性求值的 控制变量会自动声明为局部变量 仅在循环中可见

    	不要在循环过程中修改控制变量的值

  * 泛型for

    标准库提供的几种迭代器 io.lines pairs ipairs string.gmatch

     中途改变table的值

    ```lua
    local a = {1, 2, 3, 4, 5}
    for i, v in ipairs(a) do
        if i ~= 5 then
            a[i + 1] = a[i + 1] + a[i]
        end
    end
    
    -- a => {1, 4, 10, 20, 35}
    
    local a = {1, 2, 3, 4, 5}
    for i, v in ipairs(a) do
        if a[i +1] then
            print("delete")
            table.remove(a, i + 1)
        end
        print("index: " .. i .. ",key: " .. v)
    end
    --[[
    delete
    index:1, key:1
    delete
    index:2, key:3
    index:3, key:5
    -- ]]
    ```

* break 与 return

  * **break 和 return 只能是一个块的最后一条语句**

    它们应该是程序块的最后一条语句，或者是end、else或until前的一条语句

    可以通过do end 来在一个块的中间插入return或break

##### 第五章 函数

既可以完成某项特定的任务 => 语句

也可以只做一些计算并返回结果 => 表达式

一个函数若只有一个参数 并且此参数是一个字面字符串或table构造式 那么**圆括号便可有可无**

* **5.1多重返回值**

  * 只有当一个函数调用是一系列表达式中的最后一个元素时，才能获得它的所有返回值

    return (f(x)) 只会返回一个值

  * **注： unpack与`#`的关系**

    unpack() 泛型调用 从下标1开始返回数组的所有元素

* **5.2变长参数**

  * 具有变长参数的函数同样也可以拥有任意数量的固定参数 但固定参数必须放在变成参数之前

  * 变长参数中包含nil时 可以使用select来访问

    select(n, ...) 获取第n个变长参数 n = "#" 则返回变长参数的总数(包括nil)

  * 旧机制中 使用局部变量`arg`来接受所有的变长参数 `arg.n`来记录变长参数的总数

* **5.3具名实参**

  Lua参数传递机制具有位置性 

  使用table来实现具名实参 传参时只传一个table 通过索引获得某个具体的参数

#####第六章 深入函数

**第一类值**表示Lua中函数和其他传统类型的值具有相同的权利

**词法域**表示一个函数可以嵌套在另一个函数中，内部的函数可以访问外部函数的变量

函数与所有其他值一样都是匿名的（即函数名实际上是一个持有某函数引用/指针的对象）

```lua
function test()
end
-- 语法糖 函数实际上就是由表达式来创建的
test = function()
end

function(args)
    xxx
end
-- 匿名函数

```

接受另一个函数作为实参的 被称为**高阶函数**

* **6.1closure闭包**

  * 词法域

  * 内部函数中的外部函数变量 既不是全局变量也不是局部变量 =>非局部的变量

  * 一个closure就是一个函数加上该函数所需访问的所有**非局部的变量**

  * 在do end中 重新定义某个函数 可以将老版本保存在私有变量中 无法被访问 从而实现一个安全的运行环境

    ```lua
    do
        local oldSin = math.sin -- 将无法被访问到
        local k = math.pi/180
        math.sin = function(x)
            return oldSin(x * k)
        end
    end
    ```

  * 从技术上讲，Lua中只有closure，而不存在“函数”。因为，函数本身就是一种特殊的closure

* **6.2非全局的函数**

  * 

    ```lua
    -- 定义table中的函数
    local Lib = {}
    function Lib.xxx()
    ···
    end
    
    -- Lua提供了一种语法糖来定义局部函数
    local function foo()
    ...
    end
    
    local foo
    foo = function()
    ...
    end
    ```

    在递归调用时，函数需要定义完成才可调用，如下的代码是错误的：

    ```lua
    local fact = function(n)
    	if n == 0 then
    		return 1 
    	else
    		return fact(n - 1)
    	end
    end
    -- 函数体中的fact()并非此函数本身 可以使用局部函数语法糖
    local function fact(n)
        if n == 0 then
            return 1
        else 
            return n * fact * (n - 1)
        end
    end
    ```



    Lua展开局部函数定义的语法糖时 => 先定义一个局部变量 再定义函数本身

  * 对于间接递归调用，必须使用明确的前向声明

    ```lua
    local f, g -- 前向声明
    function g()
    	f()
    end
    
    function f()
    	g()
    end
    ```

* **6.3正确的尾调用**

   * 当一个函数调用是另一个函数的最后一个动作时，该调用是一条尾调用

     * 在尾调用之后，程序不需要保存任何关于该函数的栈信息。这种实现即“尾调用消除”

     * 判断的准则是 调用完之后，没有任何其他事可做。

       以下几种情况不是**尾调用**

       ```lua
       -- 还需要丢弃g(X)返回的结果
       function f(x)
       	g(x)
       end
       
       -- 必须做一次加法
       function f(x)
       	return g(x) + 1
       end
       
       ```

       在lua中 只有return <func>(<args>)这样的形式才算是一条尾调用

       lua会在调用前对func及参数求值

     * 一条尾调用就好像是一条`goto`语句

     * 尾调用的一大应用是编写状态机

##### 第七章 迭代器与泛型for

* **7.1迭代器与closure**

  迭代器就是一种可以遍历一种集合内所有元素的机制

  * 每调用一次函数，就返回集合中的下一个元素。迭代器需要在每次调用之间保持一些状态。
  * 一个closure结构涉及两个函数 closure本身和一个用于创建closure的工厂函数
  * 返回nil表示结束

* **7.2泛型for的语义**

  * 泛型for在循环过程内部保存了迭代器函数。实际上它保存了三个值：一个迭代器函数，一个恒定状态和一个控制变量。

    ```lua
    for <vat-list> in <exp-list> do
    	<body>
    end
    
    --[[
    var-list 一个或多个变量名的列表
    变量列表第一元素称为控制变量 为nil时循环结束
    exp-list 一个或多个表达式的列表
    初始化时 for对表达式求值 表达式返回三个值来供for保存迭代器函数 恒定状态 控制变量初值
    只有最后一个表达式返回多个结果 且总共只保留三个值
    初始化后 for以恒定状态和控制变量来调用迭代器函数
    ]] 
    
    do
        local _f, _s, _var = <explist>
        while true do
            local var_1, var_2, ..., var_n = _f(_s, _var)
            _var = var_1
            if _var == nil then
                break
            end
        end
    end
    
    
    --ipairs lua实现
    local function iter(a, i)
        i = i + 1
        local v = a[i]
        if v then
            return i, v
        end
    end
    
    function ipairs(a)
        return iter, a, 0
    end
    ```

* **7.3无状态的迭代器**

  * 自身不保存任何状态的迭代器，可以再多个循环中使用同一个无状态的迭代器。

* **7.4具有复杂状态的迭代器**

  * 复杂状态：使用closure 或 将所有需要的状态打包为table，保存在恒定状态中

  * 在循环过程中，恒定状态总是同一个table，但table的内容可以改变。
  * 基于closure的迭代器比使用一个table的迭代器更高效：
    * 创建一个closure比创建一个table更廉价
    * 访问非局部的变量也比访问table字段快
  * 使用协程编写迭代器是功能最强的。

* **7.5真正的迭代器**

  真正做迭代的是for循环 而迭代器只是为每次迭代提供一些成功后的返回值

  创建一个真正的迭代器 不需要循环 传入一个函数表示需要进行的操作 并在内部循环中调用这个函数

  * 生成器风格的迭代器更加灵活

##### 第八章 编译 执行 与错误

区别解释型语言的主要特征不在于是否能编译它们，而是在于编译器是否是语言运行时库的一部分，即是否有能力（并且轻易地）执行动态生成的代码。可以说，正是因为存在了诸如dofile这样的函数，才可以将Lua称为是一种解释型语言

* **8.1编译**

  * loadfile与dofile

    dofile运行代码块

    loadfile加载代码块 编译但不运行 将编译结果作为函数返回

  * loadstring 从字符串中读取代码而非文件中 将编译结果作为函数返回 直接调用即可运行 => loadstring(s)()

    在编译时不涉及词法域，总是在全局环境中编译它的字符串

  * loadfile loadstring都是基于load实现的 一般不会使用load

  * 在Lua中，函数定义是一种赋值操作，也就是说，它们是在运行时才完成的操作

* **8.2C代码**

  * C代码需要在使用前先链接入一个应用程序，动态链接不是ANSI C标准的一部分，也就是说不存在任何可移植的方案来实现它

  * Lua为几种平台实现了一套动态链接机制

  * Lua提供的所有关于动态链接的功能都聚集在一个函数中package.loadlib

    两个参数 动态库路径和函数名称

  * loadlib非常底层 通常使用require来加载C程序库

    require()会搜索指定的库，然后使用package.loadlib来加载库，并返回初始化函数

    详见15.1require 26.2C程序库

* **8.3错误**

  lua是一种扩展语言，在发生错误时不能简单地崩溃或退出，相反，只要发生了一个错误，就应当结束当前程序块并返回应用程序

  * error()
  * assert() => if not <condition> then error()

* **8.4错误处理与异常**

  * pcall()

    pcall会以一种保护模式来调用它的第一个参数，因此pcall可以捕获函数执行中的任何错误，没有错误则返回true和函数调用值，否则返回false及错误消息

  * **使用error来抛出异常 使用pcall来捕获异常 error参数即错误消息可以是任何类型的lua值**

* **8.5错误消息与追溯(traceback)**

  错误消息:

  	1.遇到内部错误时，Lua会产生错误消息

  	2.error的参数

  错误消息通常是描述了出错内容的字符串	 只要错误消息是字符串，Lua就会附加一些关于错误发生位置的信息(文件名及行号)

  * error() 第二个参数用来标识错误发生在哪个层级

  * pcall返回错误消息时，已经销毁了调用栈的部分内容 

    在返回前获取信息 xpcall() 除了接受一个需要被调用的函数外，还接受第二个参数一个错误处理函数

    可以在错误处理函数中使用debug库来获取关于错误的额外信息

  * debug.debug() debug.trackback()

#####第九章 协同程序（coroutine)

协同程序与线程差不多，也就是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时又与其他协同程序共享全局变量和其他大部分东西。

线程与协程的区别：在任意时刻只能同时运行一个协同程序，正在执行的协程只有在显示要求挂起时，执行才会暂停。

* **9.1协同程序基础**

  * Lua将所有关于协同程序的函数都放在一个名为"coroutine"的table中

  * create(function) 创建一个协程 function即该协程需要执行的内容 返回一个thread类型的值

    刚创建时 处于挂起状态

  * 4种状态 挂起suspended 运行running 死亡dead 正常normal

  * status(thread) 检查状态

  * resume(thread) 将状态由挂起改为运行

  * yield() 挂起

    所有在挂起时发生的活动都发生在yield调用中，当恢复协同程序的执行时，对于yield的调用才最终返回

  * 协同程序内容执行完毕，则程序处于死亡状态

    对已死亡的协程 调用resume将返回false及一条错误消息

  * 保护模式（pcall）

  * A唤醒B时 A处于正常状态(无法运行也不在运行)

  * resume-yield交换数据

    ```lua
    -- 第一次调用resume时，额外的参数被视为协同程序主函数的参数
    co = coroutine.create(function(a, b, c)
    	print("co", a, b, c)
    end)
    coroutine.resume(co, 1, 2, 3) --> co 1 2 3
    
    co = coroutine.create(function(a, b)
    	coroutine.yield(a + b, a - b)
    end)
    print(coroutine.resume(co, 20, 10)) --> true 30 10
    -- resume返回的内容中 第一个值为true表示没有错误 额外值为yield()的参数
    -- yield返回的额外参数即对应resume传入的参数
    -- 协程结束时，主函数返回的值将作为resume的返回值
    
    --[[
    1.create => 主函数 挂起
    2.第一次resume 参数 => 调用的函数及主函数的参数
    3.遇到yield 挂起
    4.再次调用resume yield返回 参数 => 调用的函数及yield的返回值
    5.resume返回值 第一个值为true表示没有错误 后面的值为yield的参数
    最后一次为主函数返回值
    ]]
    ```

  * resume() yield() **非对称的协同程序** 即通过两个函数来控制协程的挂起和恢复

  * Lua提供了**完整的** **非对称**的协同程序(不完整的类似于python中的generator 只有协同程序的主函数才能调用类似于yield之类的函数用于挂起)

* **9.2管道pipe和过滤器filter**

  * 使用协程解决**生产者消费者问题**  **消费者驱动**

    通过消费者来启动 当消费者需要一个新值时，它唤醒生产者，生产者返回一个新值后停止运行，并等待消费者再次唤醒

  * 实现**过滤器** 既是生产者又是消费者 filter介于生产者消费者之间

    pipe unix 切换的代价大于filter(filter切换代价大致相当于一次函数调用)

- **9.3以协同程序实现迭代器**

  将循环迭代器视为生产者-消费者模式的一个特例

  coroutine.wrap()

- **9.4非抢先式的多线程**

  当一个协同程序运行时，无法从外部停止它

  select()

---

##### 完整的示例

* 数据描述

* 马尔科夫链

  根据原始文本中n个单词的序列来确定后面的单词

---



####第二部分

第二章为Lua高级语法部分

主要是围绕table以及元表来实现一些复杂机制

第11章 使用table实现各种数据结构

第12章 数据读取

第13章 介绍了元表和元方法

第14章 介绍了环境

第15章 介绍了模块与包

第16章 面向对象的实现

第17章 弱引用table

#####第十一章 数据结构

使用table来实现一些传统的数据结构

* **11.1数组**

  * 使用整数索引table即可实现数组
  * Lua中习惯以1作为数组的起始索引

* **11.2矩阵与多维数组**

  * 矩阵 两种实现方式
     * 数组的数组 `a[m][n]`

       必须显示地创建每一行

       更加灵活

     * 合并索引`a[(i - 1)*M + j]`
  * 稀疏矩阵

     * Lua本身就是稀疏的 不会造成空间浪费
     * 稀疏矩阵不能使用`#`操作符 使用`pairs()`来遍历 是无序的

* **11.3链表**

  * 实现

    ```lua
    local list = nil
    for i = 1, 10 do
    	list = {next = list, value = i}
    end
    ```

  * Lua中很少使用链表

* **11.4队列与双向队列**

  * `table.insert()` `table.remove()` 对于大结构 开销大
  * 使用两个索引值来标记首尾元素

* **11.5集合与无序组**

  * 集合 即以字符串作为索引 查找时不需要搜索直接索引即可

  * 包 也称为 多重集合 每个元素可以出现多次

    ```lua
    bag[element] = num -- 计数器
    ```

* **11.6字符串缓冲**

  * `..`字符串连接符 先创建新字符串，再复制原字符串，当字符串过大时，每次操作移动内存将导致较大性能开销。

  * table.concat() io.read("*all")

  * 内部使用了算法来创建较大的字符串

    使用栈来存放字符串，当入栈的字符串比栈顶字符串长时 就进行连接操作 并继续向下比较 遇到更长的字符串或到达栈底 否则直接进行入栈操作

* **11.7图**

  * 以结点为对象（table) 用name字段表示结点的名字 adj字段表示与该结点邻接的结点的集合

##### 第十二章 数据文件与持久性

使用Lua来避免程序中所有有关数据读取的代码

* **12.1数据文件**

  * CSV XML

  * 使用Lua构造式作为格式 => 自描述的数据

    Lua不仅运行速度快，编译速度也快
* **12.2串行化**

  * 串行化 即将数据转换为字节流或字符流
  * string.format("%q", str)
  * 保存无环的table
  * 保存有环的table

##### 第十三章 元表(metatable)与元方法(metamethod)

通常 Lua中每个值都有一套预定义的操作集合

通过元表来修改一个值的行为，使其在面对一个非预定义的操作时执行一个指定的操作。

Lua中每个值都有一个元表 table和userdata可以有各自独立的表 其他类型的值共享类型所属的单一元表

创建table时不会创建元表

`getmetatable(table)` `setmetatable(table, t1)`

一个table甚至可以作为它自己的元表

在Lua代码中 只能设置table的元表 其他类型需要通过C代码来完成 

默认没有元表 字符串程序库给字符串类型设置了一个元表

- **13.1算数类的元方法**

  在云表中，每种算数操作符都有对应的字段名。

  __add +

  __mul *

  __sub -

  __div /

  __unm ~

  __mod %

  __pow ^

  __concat ..

  t1.__add = func

  如果符号两边具有不同元表 先查找第一个值得元表 再查找第二个值

  * 当一个表达式中混合了具有不同元表的值时，Lua会按照如下步骤来查找元表

    先查找第一个值的元表，再查找第二个值的元表， 都没有则引发错误

- **13.2关系类的元方法**

  __eq 等于

  __lt  小于

  __le 小于等于

  其他3个操作符 ~= > >=被转化成上述三个操作符

  - **部分有序**

    对一种类型而言，并不是所有的值都能排序

  - 关系类元方法不能应用于混合的类型(不同类型/拥有不同元方法) 可以是不同元表

    等于比较不会引发错误 两个对象拥有不同元方法时 等于操作直接返回false

    只有两个比较对象共享一个元方法时 Lua才调用这个等于比较的元方法

- **13.3库定义的元方法**

  __tostring

  __metatable 保护元表 不能看和修改元表 getmetatable会返回这个字段的值 setmetatable引发一个错误

- **13.4table访问的元方法**

  算数类和关系类是为原本错误情况定义行为 

  也可以修改table的行为：查询table 和 修改table中不存在的字段

  - __index

    访问不存在的字段时 会查找__index元方法

    __index元方法不必一定是函数 也可以是table

    使用rawget 在访问table时 不涉及元方法

  - __newindex

    __newindex用于更新

    __index用于查询

    赋值时查找__newindex 如果是函数 则调用它 如果元方法是table 就对该table赋值 而不是原来的table

    rawset()

  - 具有默认值的table

    - 用__index设置默认值
    - 弱引用table  备忘录元表 见17章

  - 跟踪table的访问

  - 只读的table

##### 第十四章 环境

Lua中所有全局变量存在一个常规的table中，即"环境"

将环境table自身保存在_G中

- **14.1具有动态名字的全局变量**

  看不懂啊

  ```lua
  a = {}
  a.b = 1
  print(_G["a.b"]) -- -> nil
  -- 这种属于动态名字？ 意义在哪呢？
  ```

- **14.2全局变量声明**

  通过元表来改变访问全局变量时的行为

- **14.3非全局的环境**

  允许每个函数拥有一个自己的环境来查找全局变量

  `setfenv`改变一个函数的环境 第一个参数可以是函数也可以是数字（表示当前函数调用栈中的层数）

  函数继承创建它的函数的环境，若父函数环境改变，子函数的环境也会改变

##### 第十五章 模块与包

`require`使用模块 `module`创建模块

- **15.1require函数**

  **对于require而言 模块就是一段定义了一些值的代码**（可能是函数或包含函数的table）

  返回一个由模块函数组成的table  还会定义一个包含该table的全局变量(返回的值由模块决定)

  package.loaded 保存已加载过的模块

  findloader寻找加载器 在package.preload中查询传入的模块名 如果在其中找到了一个函数 就以该函数作为模块的加载器

   `loadfile`加载lua文件 `loadlib`加载C程序库

  LUA_PATH package.path保存搜索Lua文件的路径 用分号隔开不同路径

  LUA_CPATH package.cpath搜索C程序库的路径

  luaopen_模块名 以a-b来命名模块 避免名称冲突

- **15.2编写模块的基本方法**

  最简单的方法 创建一个table 将需要的函数放入其中 最后返回这个table

- **15.3使用环境**

  通过设置环境来解决创建模块时遇到的问题。

- **15.4module函数**

  `module()`会创建一个新的table 并将其赋予适当的全局变量和loaded table 并将该table设为主程序块的环境

- **15.5子模块与包**

  Lua支持具有层级性的模块吗 `mod.sub`

  包是一个完整的模块树 Lua中发行的单位

  当搜索一个定义子模块的文件时，require会将点转换为另一个字符，通常是系统的目录分隔符，这样就可以将一个包中的所有模块组织到一个目录中。

  从Lua的观点看，同一个包中的子模块除了它们的环境table是嵌套的之外它们之间并没有显示的关联性

##### 第十六章 面向对象编程

table就是一种对象

   1.拥有状态

2. 拥有一个独立于其值得标识（self）
3. 独立于创建者和创建地的生命周期

对象有自己的操作 即 方法

缺少类 继承和私密性

通过元表__index元方法来实现类和类的继承

- **16.1类**

  类 创建对象的模具

  创建一个专用作其他对象的原型，类和原型都是一种组织对象间共享行为的方式

  通过继承机制来实现类

- **16.2继承**

- **16.3多重继承**

  用一个函数作为__index元字段 可以让\_\_index函数在其他地方查找缺失的key

- **16.4私密性**

  一个table用来保存对象的状态

  另一个用于对象的操作

- **16.5单一方法的做法**

  将单独的方法作为对象表示来返回

##### 第十七章 弱引用table

Lua采用自动内存管理 通过使用垃圾收集机制 会自动删除那些已经成为垃圾的对象

弱引用用来告诉Lua一个引用不应该阻碍一个对象的回收 就是一种会被垃圾收集器忽视的对象引用

如果一个对象的所有引用都是弱引用 那么Lua就可以回收这个对象了 并且还可以以某种形式来删除这些弱引用本身

弱引用table即具有弱引用条目(key 或 value)的table

__mode元方法来设置弱引用 包含"k"或包含"v" 包含"k"说明key是弱引用的 包含"v"说明value是弱引用的

Lua只会回收弱引用table中的对象 数字和布尔这样的值时不可回收的

如果key是数字 布尔值 字符串时 不会被回收

- **17.1备忘录函数**

  空间换时间 用table记录下函数计算的结果 复用

  将table设为弱引用 可以删除没用到的结果 减少内存损耗

- **17.2对象属性**

  将属性与对象关联起来

  使用外部table来绑定对象属性

  使用弱引用防止对象无法被回收

- **17.3回顾table的默认值**

  两种设置默认值的技术：备忘录和对象属性的特殊应用

  1.弱引用table将table与默认值关联起来(对象属性)

  2.对不同默认值使用不同元表(备忘录)

####第三部分

第三部分主要介绍了Lua中一些常用的库

第18章 数学库

第19章 table库

第20章 字符串库

第21章 I/O库

第22章 操作系统库

第23章 调试库

#####第十八章 数学库

三角函数 sin cos tan asin acos

	使用弧度单位 使用函数deg rad来转换角度和弧度

指数和对数函数 exp log log10

取整函数 floor ceil

max min

随机数 random randomseed

random:

	不提供参数 返回[0 , 1)

	整数n做参数 [1, n]内的伪随机整数

	两个整数参数m, n 返回[m, n]内的伪随机整数

randomseed:

	根据种子参数来生成伪随机数序列

pi huge（Lua可以表示的最大数字）

##### 第十九章 table库

* **19.1插入和删除**

  `table.insert()` 没有指定位置 则默认添加到末尾

  `table.remove()` 

* **19.2排序**

  `table.sort()`

  希望第一个参数排在第二个参数前 则返回true

* **19.3连接**

  `table.concat()` 

  介绍一个字符串数组 返回字符串连接后的结果

  可选参数 用于指定插入到字符串之间的分隔符

  还介绍两个可选参数 用于指定第一个和最后一个要连接的字符串索引

##### 第二十章 字符串库

在Lua5.1中 还将sting库中的函数作为string类型的方法(通过元表)

`string.upper(s)` or `s:upper()`

* **20.1基础字符串函数**

  `string.len(s)`返回长度

  `string.rep(s, n)`返回s重复n次

  `string.upper()`

  `string.lower()`

  `string.sub(s, i, j)`提取第i到第j个字符 第一个字符索引为1 -1表示最后一个

  `string.char()` 整数转化成对应字符

  `string.byte()` 默认返回第一个字符的内部数值表示

  `string.format()`格式化字符串 % + d十进制 x十六进制数 o八进制 f浮点数 s字符串(%.4f表示小数点后有4个数字 %02d 2个十进制数 不足用0补 %2d用空格补)

* **20.2模式匹配函数**

  find match gsub gmatch

  POSIX

  * string.find(s, "xxx", j) 在字符串s的第j位开始查找子串"xxx" 返回起始索引和结尾索引

  * match 与find非常相似 返回的是目标字符串中与模式相匹配的那部分子串 而非该模式所在的位置

  * gsub 参数 目标字符串 模式 替换字符串 第四个可选参数 替换的次数

    将目标字符串中所有出现模式的地方替换为替换字符串

    返回 1.匹配后的字符串 2.实际替换的次数

    (select(index, func) 返回函数的第index个返回值)

  * gmatch 返回一个函数 通过这个函数可以遍历到一个字符串中所有出现指定模式的地方

* **20.3模式**

  字符分类：

  %a 字母

  %c 控制字符

  %d 数字

  %l 小写字母

  %p 标点符号

  %s 空白字符

  %u 大写字母

  %w 字母和数字字符

  %x 十六进制数字

  %z 内部表示为0的字符

  % + 大写 表示补集 即非XXX

  魔法字符：

  ( ) . % + - * ? [ ] ^ $ 

  * 转义 % + XX 可用于所有非字母、数字的字符

    Lua转义字符 \  模式的转义字符%

    只有模式函数才会把%当做转义字符

  * [ ]括号可创建属于用户自己的字符分类即 字符集

    例：[%w_]表示同时匹配字母数字下划线

  * 横线表示范围[0-9]

  * 在字符集前面加^ 取补集

  * 字符分类使用与lua相同的区域设置 所以[a-z]不一定等同于%l

  * `+ - * ? `修饰符 表示模式中的重复部分和可选部分

    `+`重复一次或多次 取与模式相匹配的最长序列

    %a+ 匹配一个或多个字母

    ` - *`重复0次或多次 `-`和`*`一样 但会匹配最短的子串 `*`最长子串

    最短子串和最长子串

    `?`可选0次或1次

    Lua的修饰符只能应用于一个字符分类 无法对一组分类进行修饰

  * 模式以^开头 只匹配目标字符串的开头部分

    以$结尾 只匹配目标字符串的结尾部分

  * %b用于匹配成对的字符

    %b<x><y> => %b()匹配以“(”开始以“)”结束的子串

* **20.4捕获**

  根据一个模式从目标字符串中抽出匹配于该模式的内容，在指定捕获时，应将模式中需要捕获的部分写到一对圆括号内。

  string.match会将所有捕获到的值作为单独的结果返回 即会将目标字符串切成多个捕获到的部分

  在捕获内使用%d表示第d个被捕获的值

  使用gsub 也可以使用%d 其中 %0表示整个匹配

* **20.5替换**

  gsub的第三个参数可以是函数或table

  以捕获到的内容为参数调用函数 返回值为要替换的值 函数返回nil不做替换

  以捕获到的内容为key  value为要替换的值 不含该key则不改变匹配

  * URL编码

  * tab扩展

    ()空白捕获不代表捕获空内容 而是捕获它在目标字符串中的位置

    print(string.match("hello", "()ll()"))   --> 3 5

* **20.6技巧**

  注意效率

  宽泛的模式会比精确的模式慢许多

  空模式

##### 第二十一章 I/O库

I/O库为文件操作提供了两种不同的模型，简单模型和完整模型

简单模型假设有一个当前输入文件一个当前输出文件

完整模型则使用显示的文件句柄

* **21.1简单I/O模型**

  所有操作都作用于两个当前文件 stdin stdout

  io.read()从标准输入中读取一行

  io.input io.output 可以改变两个当前文件

  `io.input`以只读模式打开指定文件，并将其设为当前输入文件

  io.write()写入当前输出文件

  io.write(a, b, c) > io.write(a .. b .. c) 效果相同，但可避免连接操作

  * write 与 print的不同

    write在输出时不会添加制表符或回车这样的额外字符

    write使用当前输出文件 print使用标准输出

    print能对参数自动调用tostring()方法，所以可以显示table 函数 和 nil

  io.read参数

  *all 整个文件 *line下一行 *number一个数字  \<num>不超过num个字符的字符串

  read可以指定多个选项 函数会根据每个选项参数返回相应的内容

  io.read(0)用于检查是否到达文件末尾，如果还有数据可以读取，会返回一个空字符串，否则返回nil

* **21.2完整I/O模型**

  io.open() 参数 要打开的文件名 模式字符串 r读取 w写入 a追加 b打开二进制文件

  ```lua
  local f = assert(io.open(filename, "r"))
  local t = f:read("*all")
  f:close()
  -- 打开一个文件后 可以用read/Write方法读写文件
  ```

  io.stdin io.stdout io.stderr 预定义C语言流的句柄

  * 性能小诀窍

    一次性读取整个文件比逐行地读取要快 

    处理大文件时 最快的方法就是用足够大的块来读取文件

  * 二进制文件

    io.open()参数 模式字符串为"b"表示打开二进制文件

    模式字符串不包含值为0的字节 可以用%z来表示0

  * 其他文件操作

    tmpfile()返回一个临时文件的句柄 

    io.flush f:flush()

    seek可以获取和设置一个文件的当前位置

    	f:seek(whence, offset) whence指定了如何解释offset擦书

    		set 偏移量

    		cur 当前位置偏移量

    		end 相对于文件末尾的偏移量

    		返回文件的当前位置

#####第二十二章 操作系统库

操作系统库定义在table os中 包含了文件操作函数 获取当前日期和时间的函数 以及其他一些与操作系统相关的功能。为了保证Lua的可移植性，只使用了ANSI标准中定义的函数。

文件操作：os.rename os.remove

* **22.1日期和时间**

  time() 

  	以数字形式返回当前日期和时间

  	以table作参数调用 返回一个数字 表示table中描述的日期和时间 year month day必须

  date()

  	date是time的反函数 将数组转换成高级的表现形式

  	*t 生成一个日期table os.date(\*t, xxxxxx)

  	%a 星期数简写

  	%A星期数全称

  	%b 月份简写

  	...

  os.clock()会返回当前CPU时间的秒数

* **22.2其他系统调用**

  os.exit可以中止当前程序的执行

  os.getenv可获取一个环境变量的值 接受变量名 返回对应的字符串

  os.execute可运行一条系统命令

  os.setlocale设置当前lua程序所使用的区域

  	两个字符串传参数 区域名/分类名 6种分类

##### 第二十三章 调试库

调试库由两类函数组成：自省函数 和 钩子

自省函数允许检查一个正在运行中程序的各个方面

钩子允许跟踪一个程序的执行

栈层 调用调试库的函数是层1 调用这个函数的函数是层2

* **23.1自省机制**

  主要的自省函数是debug.getinfo函数

  第一个参数可以是一个函数或一个栈层 返回一个包含了与该函数相关信息的table

  debug.traceback返回一个表示追溯结果的字符串

  * 访问局部变量

    debug.getlocal检查任意活动函数的局部变量

    debug.setlocal改变局部变量的值

  * 访问非局部的变量

    debug.getupvalue

    debug.setupvalue    getfenv(f)返回参数f所指定函数所使用的当前环境

  * 访问其他协同程序

    调试库中的所有自省函数都接受一个可选的协同程序参数作为第一个参数 这样就可以从外部来检查这个协同程序

* **23.2钩子**

  使用户可以注册一个钩子函数，这个函数会在程序运行中某个特定事件发生时被调用

  四种事件会触发一个钩子：

  1.调用一个函数时产生的call事件

  2.函数返回时产生的return事件

  3.开始执行一行新代码时产生的line事件

  4.执行完指定数量的指令后产生的count事件

  注册钩子 debug.sethook

* **23.3性能剖析**

  也可以用于一些非调试的工作 如性能剖析

####第四部分

##### 第二十四章 C API概述

C和Lua之间交互的两种形式

	第一种形式，C语言拥有控制权，Lua是一个库，这种形式中的C代码称为应用程序代码

	第二种形式，Lua拥有控制权，C语言是一个库，因此C代码称为库代码

应用程序代码和库代码都使用同样的API来与Lua通信，这些API称为C API

Lua和C通信的主要方法是一个无所不在的虚拟栈，几乎所有的API调用都会操作这个栈上的值。

C语言和Lua之间存在两大差异：

	第一种差异是Lua使用垃圾收集，而C语言要求显示地释放内存

	第二种是Lua使用动态类型，而C语言使用静态类型

* **24.1第一个示例**

  lua.h定义了Lua提供的基础函数 其中所有内容都有一个lua_前缀

  luaxlib.h luaL_开头 基于lua.hAPI的更高层的抽象 辅助库

  所有的状态都保存在动态结构lua_State中 所有的C API都要求传入一个指向该结构的指针

  luaL_newstate用于创建一个新环境

  luaL_loadbuffer编译用户输入的每行内容

  lua_pcall在保护模式运行

  lua_tostring获取消息

  lua_pop 弹出栈

  lua_close关闭Lua状态

* **24.2栈**

  栈由lua管理

  按LIFO先出后进规范来操作这个栈

  * 压入元素

    对于每种可以呈现在lua中的C类型 api都有一个对应的压入函数

    lua_pushnil lua_pushnumber lua_pushinteger 

    lua_pushboolean lua_pushlstring lua_pushstring



  	lua_checkstack用来检查栈中是否有足够的空间

  * 查询元素

    使用索引来引用栈中的元素 栈底为1 栈顶为-1

    lua_is*用来检查一个元素是否为特定的类型(是否能转换为特定类型)

    lua_type返回栈中元素的类型

    lua_to*从栈中获取一个值

    不要在C函数之外使用在C函数内获得的指向Lua字符串的指针

    lua_tostring用NULL作第三个参数来调用lua_tolstring

    lua_objlen返回一个对象的长度 对于字符串和table 是#的结果 还可以用于获取一个完全userdata的大小

  * lua_gettop

    lua_settop

    	将栈顶设置为一个指定的位置 多余弹出 不足补nil

    	#define lua_pop(L, n) lua_settop(L, -(n) - 1)

    lua_pushvalue 

    lua_remove

    lua_insert

    lua_replace

* **24.3C API中的错误处理**

  setjmp

  几乎所有的API都会抛出错误 而不是返回错误

  * 应用程序代码中的错误处理

    lua_atpanic 设置紧急函数 函数返回后 lua会结束应用

    * 设置紧急函数
    * 让代码在保护模式下运行

  * 库代码中的错误处理

    调用lua_error

    lua_error函数会清理Lua中所有需要清理的东西 然后跳转回发起执行的那个lua_pcall 并附上一条错误消息

##### 第二十五章 扩展应用程序

如何用Lua来配置一个程序

* **25.1基础**

  创建Lua状态

  加载文件 编译

  运行编译好的程序块

  获得参数

* **25.2table操作**

  lua_gettable

  	先压入key lua_pushstring(L, key)

  	再获得对应的值 lua_gettable(L, -2)

  5.1提供了lua_gettable(L, index, key)完成上述操作

  lua_settable

  	压入key lua_pushstring(L, index)

  	压入value lua_pushnumber(L, value)

  	设置 lua_settable(L, -3)

  5.1提供特化版本lua_setfield

  	压入value

  	lua_setfield

* **25.3调用Lua函数**

  将待调用的函数压入栈

  再压入函数的参数

  使用pcall进行实际调用

  将结果弹出

  lua_pcall(L, 2, 1, 0) 调用参数数量 期望的结果数量 错误处理函数索引（0表示没有）

  有多个结果时 第一个结果会优先压入

* **25.4一个通用的调用函数**

  调用lua函数的示例

##### 第二十六章 从Lua调用C

栈不是一个全局性的结构，每个函数都有自己的局部私有栈。

* **26.1C函数**

  所有注册到Lua中的函数都具有相同的原型 即定义在lua.h中的lua_CFunction

  typedef int (*lua_CFunction)(lua_State *L)

  lua使用函数之前 必须注册这个函数 使用lua_pushcfunction进行注册

* **26.2C模块**

  luaL_register

##### 第二十七章 编写C函数的技术

* 27.1数组操作
* 27.2字符串操作
* 27.3在C函数中保存状态

##### 第二十八章 用户自定义类型

* 28.1 userdata
* 28.2 元表
* 28.3 面向对象的访问
* 28.4 数组访问
* 28.5 轻量级userdata

##### 第二十九章 管理资源

* 29.1目录迭代器
* 29.2XML分析器

##### 第三十章 线程和状态

* 30.1 多个线程
* 30.2 Lua状态

##### 第三十一章 内存管理

* 31.1分配函数
* 31.2垃圾收集器