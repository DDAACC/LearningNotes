#### 我所理解的Cocos2d-x学习笔记



##### 第一章 全新的cocos2d-x 3.0

对Cocos2d-x3.0的各项改进及新功能进行一个大体的介绍，并说明这些新特性的实现意义

* Cocos2d-x3.0的历史意义

  cocos2d-x 2.x仍然保持着与cocos2d-iPhone的版本同步，主要用支持可编程管线的OpenGL ES2.0代替了针对固定管线的OpenGL ES1.x

  cocos2d-x3.0在性能、兼容性及稳定性方面得到了全面提升。

  本书从**语言风格 渲染架构 未来发展**说明历史意义

  * 语言风格

    cocos2d-x之前一直保持着与cocos-iPhone一致的Objective-C接口风格，如CC前缀

    cocos2d-x回归C++风格

  * 更灵活的渲染架构

    UI树结构 给每个元素指定了一个逻辑深度 可以按照正确的顺序绘制整个场景

    但是 **不易于扩展** 1.无法修改一个元素在全局的层级  2.每个元素负责自己的绘制 不易针对绘制做更好的优化

    3.0重新设计了渲染机制 将渲染从UI树遍历中分离出来

  * 更自由的发展

    一直以来 cocos2d-x都以保持和cocos2d-iPhone一致的API为目标 然而这限制了Cocos2d-x的发展

    3.0放弃了同步

* 3.0的新特性

  * 使用C++风格

    使用C++代替Objective-C风格 并在引擎接口设计中加入了一些C++11的特效

    * 使用命名空间代替CC前缀

    * 使用clone()代替copy()方法 深度复制一个对象

      clone直接返回一个加入自动回收池的对象 调用者不再需要手动加入

    * 用getInstance和destroyInstance代替sharedXXX 和 endXXX来使用单例

    * 使用更明确的get前缀来表示属性获取方法

    * 所有的属性获取方法使用const声明来限制对自身属性的修改

    * 对于POD类型 使用引用参数代替指针传递 **POD普通旧数据类型**

    * 使用了部分C++11特性

  * 跨平台的label

    使用FreeType字体库来解析文字和生成纹理

    还改善了字体的接口设计

  * 新的渲染系统

    遍历UI树的每一个元素时 并不直接调用openGL ES进行绘制 而是将每个元素的绘制命令包装成一个RenderCommand对象发送至绘制栈 绘制栈在遍历之后开始绘制

    好处：

    * 绘制命令可以被重用

    * 绘制命令被击中处理 可以做一些优化工作

      自动批绘制技术

    * 可以重新排序

      引入globalZOrder来设定全局的绘制顺序

    * 为sprite引入了自动裁剪技术

  * 统一的消息分发

    消息机制