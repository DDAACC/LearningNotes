### 屏幕适配

[TOC]

#### 基本概念

##### 视口

* 参考资料

  https://www.jianshu.com/p/21fa32a9bd22

* 简介

  视口就是窗口内部用于绘制裁剪区域的客户区域，openGL在视口中进行绘制

  glViewport设置了视口的大小和位置

  Windows屏幕坐标以左上角为原点, X轴正方向朝右, Y轴正方向朝下.

  视口坐标系是标准的笛卡尔直角坐标系，其原点位于渲染环境**窗口客户区**的左下角，横轴(x)向右为正，纵轴(y)向上为正

  当窗口大小改变而视口不变时，视口相对于屏幕左下角的位置是固定的，即绘制的内容相对于屏幕左下角不变。

  ```C++
  /*
  x 视口左下角的x坐标
  y 视口左下角的y坐标
  width 视口宽度
  height 视口高度
  */
  void glViewport(
      GLint x, 
      GLint y,
      GLsizei width,
      GLsizei height);
  ```

##### EGL

​	EGL 是 OpenGL ES 渲染 API 和本地窗口系统(native platform window system)之间的一个中间接口层

####cocos屏幕适配

#####GLView

负责窗口级别的功能管理和实现, 包括：坐标和缩放管理, 画图工具,按键事件

* 

  * 匿名命名空间 作用域在文件内

    g_touches

    g_indexBitsUsed 按位记录已使用的touch

    g_touchIdReorderMap

  * GLView 参数

    _scaleX _scaleY _resolutionPolicy _vrImpl _designResolutionSize _screenSize

  * pollInputEvents pollEvents

  * updateDesignResolutionSize setDesignResolutionSize getDesignResolutionSize 设计分辨率

  * getFrameSize setFrameSize 屏幕分辨率

  * getVisibleRect getVisibleSize getVisibleOrigin 可视区域

  * setViewPortInPoints getViewPortRect 

    viewPortW 设计分辨率*缩放倍数

    _viewPortRect(x, y, w, h) 居中放置 x,y 左下角坐标 w,h宽高(viewPortW) 设计分辨率区域

    glViewport(0, 0, _screenSize.width, _screenSize.height); 视口大小是屏幕分辨率大小

  * setScissorInPoints isScissorEnabled getScissorRect 裁剪

  * setViewName getViewName 窗口名称

  * handleTouchesBegin handleTouchesMove handleTouchesOfEndOrCancel getAllTouches

  * getScaleX getScaleY 缩放倍数

  * renderScene

  * GLViewTmpl

    GLView子类 使用glfw创建管理窗口，监听触摸鼠标等事件

    

* 参考资料

  https://www.cnblogs.com/yyxt/p/5514412.html

* 源码

  ```c++
  // 实际屏幕尺寸
  Size _screenSize;
  // 设计分辨率
  Size _designResolutionSize;
  // 
  Rect _viewPortRect;
  // 窗口名
  std::string _viewName;
  
  float _scaleX; //宽缩放倍数
  float _scaleY; //高缩放倍数
  ResolutionPolicy _resolutionPolicy; // 缩放策略
  ```

  ```C++
  // win32/main.cpp
  AppDelegate app;
  return Application::getInstance()->run();
  
  //Application::run()
  if (!applicationDidFinishLaunching())
  {
      return 1;
  }
  
  bool AppDelegate::applicationDidFinishLaunching()
  {
      ···
      auto glview = director->getOpenGLView();
      if(!glview) {
          glview = GLViewImpl::create("窗口名");
          director->setOpenGLView(glview);
      }
      director->setDisplayStats(true);
      director->setAnimationInterval(1.0f / 60);
      auto screenSize = glview->getFrameSize();
      auto designSize = Size(480, 320);
      ···
      glview->setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy::NO_BORDER);
  	···
      return true;
  }
  ```

  * initWithRect 初始化函数

    viewName 窗口名

    rect 窗口尺寸

    frameZoomFactor 缩放倍数

    resizable 是否可以改变窗口尺寸

    使用glfw创建管理窗口 

    使用glew获得openGL接口

  * setFrameSize 设置实际屏幕尺寸

    _screenSize

  * setViewPortInPoints

    ```C++
    void GLViewImpl::setViewPortInPoints(float x , float y , float w , float h)
    {
        experimental::Viewport vp((float)(x * _scaleX * _retinaFactor * _frameZoomFactor + _viewPortRect.origin.x * _retinaFactor * _frameZoomFactor),
            (float)(y * _scaleY * _retinaFactor  * _frameZoomFactor + _viewPortRect.origin.y * _retinaFactor * _frameZoomFactor),
            (float)(w * _scaleX * _retinaFactor * _frameZoomFactor),
            (float)(h * _scaleY * _retinaFactor * _frameZoomFactor));
        Camera::setDefaultViewport(vp);
    }
    ```

  * setDesignResolutionSize

    设置设计分辨率大小及适配策略

    ```C++
    void GLView::updateDesignResolutionSize()
    {
        if (_screenSize.width > 0 && _screenSize.height > 0
            && _designResolutionSize.width > 0 && _designResolutionSize.height > 0)
        {
            _scaleX = (float)_screenSize.width / _designResolutionSize.width;
            _scaleY = (float)_screenSize.height / _designResolutionSize.height;
            
            if (_resolutionPolicy == ResolutionPolicy::NO_BORDER)
            {
                _scaleX = _scaleY = MAX(_scaleX, _scaleY);
            }
            
            else if (_resolutionPolicy == ResolutionPolicy::SHOW_ALL)
            {
                _scaleX = _scaleY = MIN(_scaleX, _scaleY);
            }
            
            else if ( _resolutionPolicy == ResolutionPolicy::FIXED_HEIGHT) {
                _scaleX = _scaleY;
                _designResolutionSize.width = ceilf(_screenSize.width/_scaleX);
            }
            
            else if ( _resolutionPolicy == ResolutionPolicy::FIXED_WIDTH) {
                _scaleY = _scaleX;
                _designResolutionSize.height = ceilf(_screenSize.height/_scaleY);
            }
            
            // calculate the rect of viewport
            float viewPortW = _designResolutionSize.width * _scaleX;
            float viewPortH = _designResolutionSize.height * _scaleY;
            
            _viewPortRect.setRect((_screenSize.width - viewPortW) / 2, (_screenSize.height - viewPortH) / 2, viewPortW, viewPortH);
    
    
            // reset director's member variables to fit visible rect
            auto director = Director::getInstance();
            director->_winSizeInPoints = getDesignResolutionSize();
            director->_isStatusLabelUpdated = true;
            director->setProjection(director->getProjection());
    
            // Github issue #16139
            // A default viewport is needed in order to display the FPS,
            // since the FPS are rendered in the Director, and there is no viewport there.
            // Everything, including the FPS should renderer in the Scene.
            glViewport(0, 0, _screenSize.width, _screenSize.height);
        }
    }
    ```

    

  * Director

    * setContentScaleFactor(float scaleFactor)

      资源分辨率/设计分辨率

      https://blog.csdn.net/u012861978/article/details/53233892

      图片将缩放1/scaleFactor倍

      ```C++
      /*cocos新建项目中的默认处理
      设置小中大三种分辨率 将屏幕实际尺寸分别进行比较
      */
      // 如果实际高度比中等尺寸高度大 选择LH/DH LW/DW中较小的
      // if the frame's height is larger than the height of medium size.
      if (frameSize.height > mediumResolutionSize.height)
      {        
          director->setContentScaleFactor(MIN(largeResolutionSize.height/designResolutionSize.height, largeResolutionSize.width/designResolutionSize.width));
      }
      // if the frame's height is larger than the height of small size.
      else if (frameSize.height > smallResolutionSize.height)
      {        
          director->setContentScaleFactor(MIN(mediumResolutionSize.height/designResolutionSize.height, mediumResolutionSize.width/designResolutionSize.width));
      }
      // 应该是small size吧
      // if the frame's height is smaller than the height of medium size.
      else
      {        
          director->setContentScaleFactor(MIN(smallResolutionSize.height/designResolutionSize.height, smallResolutionSize.width/designResolutionSize.width));
      }
      ```

      

    * getWinSize

      _winSizeInPoints = _openGLView->getDesignResolutionSize(); 设计分辨率

    * getWinSizeInPixels

    * setViewport 设置视口大小

      _openGLView->setViewPortInPoints(0, 0, _winSizeInPoints.width, _winSizeInPoints.height);

##### 总结

https://blog.csdn.net/shenzi/article/details/53539089

http://www.voidcn.com/article/p-fwbmcscu-cn.html





visibleSize 设计分辨率在屏幕上的可视范围

visibleOrigin 可视区域左下角坐标











* 执行顺序

  * win32/main.cpp 程序入口

    AppDelegate app;
    return Application::getInstance()->run();

  * Application::run()

    applicationDidFinishLaunching 初始化

    mainLoop 主循环

    pollEvents `glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等），然后调用对应的回调函数（可以通过回调方法手动设置）。我们一般在游戏循环的开始调用事件处理函数`

    ```C++
    int Application::run()
    {
        PVRFrameEnableControlWindow(false);
    
        // Main message loop:
        LARGE_INTEGER nLast;
        LARGE_INTEGER nNow;
    
        QueryPerformanceCounter(&nLast);
    
        initGLContextAttrs();
    
        // Initialize instance and cocos2d.
        if (!applicationDidFinishLaunching())
        {
            return 1;
        }
    
        auto director = Director::getInstance();
        auto glview = director->getOpenGLView();
    
        // Retain glview to avoid glview being released in the while loop
        glview->retain();
    
        while(!glview->windowShouldClose())
        {
            QueryPerformanceCounter(&nNow);
            if (nNow.QuadPart - nLast.QuadPart > _animationInterval.QuadPart)
            {
                nLast.QuadPart = nNow.QuadPart - (nNow.QuadPart % _animationInterval.QuadPart);
                
                director->mainLoop();
                glview->pollEvents();
            }
            else
            {
                Sleep(1);
            }
        }
    
        // Director should still do a cleanup if the window was closed manually.
        if (glview->isOpenGLReady())
        {
            director->end();
            director->mainLoop();
            director = nullptr;
        }
        glview->release();
        return 0;
    }
    ```

  * applicationDidFinishLaunching 

    初始化glview

    设置FPS

    设置屏幕适配策略

    director->runWithScene(scene); 创建主场景

    ```C++
    bool AppDelegate::applicationDidFinishLaunching() {
        // initialize director
        auto director = Director::getInstance();
        auto glview = director->getOpenGLView();
        if(!glview) {
    #if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) || (CC_TARGET_PLATFORM == CC_PLATFORM_LINUX)
            glview = GLViewImpl::createWithRect("FlappyBird", cocos2d::Rect(0, 0, 1600, 900));
    #else
            glview = GLViewImpl::create("FlappyBird");
    #endif
            director->setOpenGLView(glview);
        }
    
        // turn on display FPS
        director->setDisplayStats(true);
    
        // set FPS. the default value is 1.0/60 if you don't call this
        director->setAnimationInterval(1.0f / 60);
    
        // Set the design resolution
    	glview->setDesignResolutionSize(designResolutionSize.width, designResolutionSize.height, ResolutionPolicy::SHOW_ALL);
    
        register_all_packages();
    
        // create a scene. it's an autorelease object
    	auto scene = MainScene::createScene();
    
        // run
        director->runWithScene(scene);
    
        return true;
    }
    ```

    *  Director::runWithScene(Scene *scene)

      ```C++
      void Director::runWithScene(Scene *scene)
      {
          CCASSERT(scene != nullptr, "This command can only be used to start the Director. There is already a scene present.");
          CCASSERT(_runningScene == nullptr, "_runningScene should be null");
      
          pushScene(scene);
          startAnimation();
      }
      ```

  * Director::mainLoop()

    drawScene();

    PoolManager::getInstance()->getCurrentPool()->clear();

    ```c++
    void Director::mainLoop()
    {
        if (_purgeDirectorInNextLoop)
        {
            _purgeDirectorInNextLoop = false;
            purgeDirector();
        }
        else if (_restartDirectorInNextLoop)
        {
            _restartDirectorInNextLoop = false;
            restartDirector();
        }
        else if (! _invalid)
        {
            drawScene();
         
            // release the objects
            PoolManager::getInstance()->getCurrentPool()->clear();
        }
    }
    ```

    * Director::drawScene()

      pollEvents => dispatchEvent

      _eventBeforeUpdate

      _scheduler

      _eventAfterUpdate

      _openGLView->renderScene(_runningScene, _renderer)

      _eventAfterVisit

      _renderer->render()

      _eventAfterDraw

      ```C++
      // Draw the Scene
      void Director::drawScene()
      {
          // calculate "global" dt
          calculateDeltaTime();
          
          if (_openGLView)
          {
              _openGLView->pollEvents();
          }
      
          //tick before glClear: issue #533
          if (! _paused)
          {
              _eventDispatcher->dispatchEvent(_eventBeforeUpdate);
              _scheduler->update(_deltaTime);
              _eventDispatcher->dispatchEvent(_eventAfterUpdate);
          }
      
          _renderer->clear();
          experimental::FrameBuffer::clearAllFBOs();
          /* to avoid flickr, nextScene MUST be here: after tick and before draw.
           * FIXME: Which bug is this one. It seems that it can't be reproduced with v0.9
           */
          if (_nextScene)
          {
              setNextScene();
          }
      
          pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
          
          if (_runningScene)
          {
      #if (CC_USE_PHYSICS || (CC_USE_3D_PHYSICS && CC_ENABLE_BULLET_INTEGRATION) || CC_USE_NAVMESH)
              _runningScene->stepPhysicsAndNavigation(_deltaTime);
      #endif
              //clear draw stats
              _renderer->clearDrawStats();
              
              //render the scene
              _openGLView->renderScene(_runningScene, _renderer);
              
              _eventDispatcher->dispatchEvent(_eventAfterVisit);
          }
      
          // draw the notifications node
          if (_notificationNode)
          {
              _notificationNode->visit(_renderer, Mat4::IDENTITY, 0);
          }
      
          if (_displayStats)
          {
              showStats();
          }
          _renderer->render();
      
          _eventDispatcher->dispatchEvent(_eventAfterDraw);
      
          popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
      
          _totalFrames++;
      
          // swap buffers
          if (_openGLView)
          {
              _openGLView->swapBuffers();
          }
      
          if (_displayStats)
          {
              calculateMPF();
          }
      }
      ```

      